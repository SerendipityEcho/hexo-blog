{"meta":{"title":"extends","subtitle":"","description":"个人博客","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-11-17T07:26:24.256Z","updated":"2022-11-17T07:26:24.256Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-11-17T07:26:32.881Z","updated":"2022-11-17T07:26:32.881Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-11-17T07:27:22.655Z","updated":"2022-11-17T07:27:22.655Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-11-17T07:26:47.058Z","updated":"2022-11-17T07:26:47.058Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"docker笔记","slug":"docker笔记","date":"2022-12-09T08:14:47.000Z","updated":"2022-12-09T08:16:17.265Z","comments":true,"path":"2022/12/09/docker笔记/","link":"","permalink":"http://example.com/2022/12/09/docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装dockerDocker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。 Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。 所以，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。 Linux系统安装与卸载使用官方安装脚本自动安装安装命令如下： 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令： 1curl -sSL https://get.daocloud.io/docker | sh curl是一个利用 URL 语法，在终端下使用的网络请求工具，支持 HTTP、HTTPS、FTP 等协议。CURL 也有用于程序开发使用的版本 libcurl。 Linux、MAC 一般系统默认已安装好 curl，直接在终端使用命令即可，如果需要手动安装，可以到 curl.haxx.se 下载安装。 卸载 docker删除安装包： 1yum remove docker-ce 删除镜像、容器、配置文件等内容： 1rm -rf /var/lib/docker 使用docker命令基本上都是以docker开头。 docker要运行首先需要有一个镜像(images)，通过镜像创建容器，之后在容器中即可进行自己的操作。 这一点可以理解为java中首先需要有一个类，然后通过new 类名 的方式创建出这个类的实例之后才可以使用这个类一样。 Docker 镜像使用查看本地镜像当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。 使用指令docker images查看本地主机上的所有镜像。 123REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 3358aea34e8c 2 weeks ago 117MBubuntu latest a8780b506fa4 4 weeks ago 77.8MB REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 使用镜像使用指令docker run -t -i ubuntu[:指定版本] /bin/bash 运行容器 -i: 交互式操作。 -t: 终端。 ubuntu:[15.10]: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。 &#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。 1$ docker run -t -i ubuntu:15.10 /bin/bash 下载新镜像使用指令docker pull [需要下载的镜像:版本]下载指定镜像。 1$ docker pull ubuntu:13.10 删除镜像使用指令docker rmi [镜像名称]删除指定镜像 1$ docker rmi ubuntu:15.10 创建镜像当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。 1、从已经创建的容器中更新镜像，并且提交这个镜像 2、使用 Dockerfile 指令来创建一个新的镜像 更新镜像更新镜像之前，我们需要使用镜像来创建一个容器。 1$ docker run -t -i ubuntu:15.10 /bin/bash 在运行的容器内使用 apt-get update 命令进行更新。 在完成操作之后，输入 exit 命令来退出这个容器。 此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。 1$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2 各个参数说明： -m: 提交的描述信息 -a: 指定镜像作者 e218edb10161：容器 ID runoob&#x2F;ubuntu:v2: 指定要创建的目标镜像名 我们可以使用 docker images 命令来查看我们的新镜像 runoob&#x2F;ubuntu:v2： 1234567891011runoob@runoob:~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v2 70bf1840fd7c 15 seconds ago 158.5 MBubuntu 14.04 90d5884b1ee0 5 days ago 188 MBphp 5.6 f40e9e0f10c8 9 days ago 444.8 MBnginx latest 6f8d099c3adc 12 days ago 182.7 MBmysql 5.6 f2e8d6c772c0 3 weeks ago 324.6 MBhttpd latest 02ef73cf1bc0 3 weeks ago 194.4 MBubuntu 15.10 4e3b13c8a266 4 weeks ago 136.3 MBhello-world latest 690ed74de00f 6 months ago 960 Btraining/webapp latest 6fae60ef3446 12 months ago 348.8 MB 使用我们的新镜像 runoob&#x2F;ubuntu 来启动一个容器 1runoob@runoob:~$ docker run -t -i runoob/ubuntu:v2 /bin/bash Docker 容器使用启动容器使用指令docker run -itd ubuntu /bin/bash启动一个容器。 -i: 交互式操作。 -t: 终端。 -d: 后台运行。 ubuntu: ubuntu 镜像。 &#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。 查看容器1$ docker ps -a 启动已停止的容器1$ docker start [容器id | 容器名称] 停止容器1$ docker stop &lt;容器名称 | ID&gt; 进入容器在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach docker exec：推荐使用 ，此命令在退出容器终端时不会导致容器停止。 attach 命令 1$ docker attach 1e560fca3906 注意： 如果从这个容器退出，会导致容器的停止。 exec 命令 1$ docker exec -it 243c32535da7 /bin/bash 删除容器删除容器使用 docker rm 命令： 1$ docker rm -f 1e560fca3906 导出和导入容器导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 1$ docker export 1e560fca3906 &gt; ubuntu.tar 导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。 导入容器快照 可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test&#x2F;ubuntu:v1: 1$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1 也可以通过指定 URL 或者某个目录来导入，例如： 1$ docker import http://example.com/exampleimage.tgz example/imagerepo Docker 容器连接容器中可以运行网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 网络端口映射指令： 1$ docker run -d -P 镜像名:版本 [命令] 1$ docker run -itd --name 容器名称 -p 主机端口:容器端口 镜像名:版本 [命令] 放在镜像名后的是命令，例： 1$ docker run -itd --name redis-test -p 6379:6379 redis -P :是容器内部端口随机映射到主机的端口。 -p : 是容器内部端口绑定到指定的主机端口。 我们使用 -P 绑定端口号，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768。 123runoob@runoob:~$ docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMESfce072cc88ce training/webapp &quot;python app.py&quot; ... 0.0.0.0:32768-&gt;5000/tcp grave_hopper 默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 &#x2F;udp。例： 1$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py docker port 命令可以快捷地查看端口的绑定情况。 12user@ubuntu:~$ docker port redis-test 63790.0.0.0:6379 Docker Dockerfile简介Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 流程： 创建Dockerfile文件 在文件中编写镜像构建命令 运行命令构建镜像 构建Dockerfile文件和要放入镜像中的文件需要放在同一目录下 使用指令执行构建操作 1$ docker build -t 镜像名:版本 上下文路径 示例 1$ docker build -t nginx:v3 . PS : 上下文路径就是一个路径，docker执行打包会将这个路径下的所有文件发送的docker服务端进行打包（ddocker是C&#x2F;S架构，打包操作是在服务端进行的） 示例123456789101112131415161718# 构建镜像基于哪个镜像FROM anapsix/alpine-java:8_server-jre_unlimited# 镜像维护者姓名或邮箱地址MAINTAINER test@163.com# 构建镜像时运行的指令RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeRUN mkdir -p /jero-boot# 这样执行run命令会创建两层镜像，可以使用 &amp;&amp; 连接命令# RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# &amp;&amp; mkdir -p /jero-boot# 设置工作目录WORKDIR /jero-boot# 声明容器的服务端口EXPOSE 8080# 拷贝文件或目录到容器中ADD ./target/jero-boot-module-system-2.4.6.jar ./# 运行容器时执行的shell环境CMD sleep 60;java -Djava.security.egd=file:/dev/./urandom -jar jero-boot-module-system-2.4.6.jar Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 指令详解COPY复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 格式： 12COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] **[–chown&#x3D;:]**：可选参数，用户改变复制到容器内文件的拥有者和属组。 **&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ **&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 ADDADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下： ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 CMD类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: CMD 在docker run 时运行。 RUN 是在 docker build。 作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 格式： 123CMD &lt;shell 命令&gt; CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。 ENTRYPOINT类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。 但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。 优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。 注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 格式： 1ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。 示例： 假设已通过 Dockerfile 构建了 nginx:test 镜像： 1234FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 1、不传参运行 1$ docker run nginx:test 容器内会默认运行以下命令，启动主进程。 1$ nginx -c /etc/nginx/nginx.conf 2、传参运行 1$ docker run nginx:test -c /etc/nginx/new.conf 容器内会默认运行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件) 1$ nginx -c /etc/nginx/new.conf ENV设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 格式： 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 以下示例设置 NODE_VERSION &#x3D; 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用： 1234ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \\ &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; ARG构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。 构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。 格式： 1ARG &lt;参数名&gt;[=&lt;默认值&gt;] VOLUME定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。 作用： 避免重要的数据，因容器重启而丢失，这是非常致命的。 避免容器不断变大。 格式： 12VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt; 在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。 EXPOSE仅仅只是声明端口。 作用： 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 格式： 1EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] WORKDIR指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。 格式： 1WORKDIR &lt;工作目录路径&gt; USER用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。 格式： 1USER &lt;用户名&gt;[:&lt;用户组&gt;] HEALTHCHECK用于指定某个程序或者指令来监控 docker 容器服务的运行状态。 格式： 123HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。 ONBUILD用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。 格式： 1ONBUILD &lt;其它指令&gt; LABELLABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下： 1LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... 比如我们可以添加镜像的作者： 1LABEL org.opencontainers.image.authors=&quot;author&quot; Dockerfile指令简洁版 FROM 构建镜像基于哪个镜像 MAINTAINER 镜像维护者姓名或邮箱地址 RUN 构建镜像时运行的指令 CMD 运行容器时执行的shell环境 VOLUME 指定容器挂载点到宿主机自动生成的目录或其他容器 USER 为RUN、CMD、和 ENTRYPOINT 执行命令指定运行用户 WORKDIR 为 RUN、CMD、ENTRYPOINT、COPY 和 ADD 设置工作目录，就是切换目录 HEALTHCHECH 健康检查 ARG 构建时指定的一些参数 EXPOSE 声明容器的服务端口（仅仅是声明） ENV 设置容器环境变量 ADD 拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压 COPY 拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能 ENTRYPOINT 运行容器时执行的shell命令 Docker Compose简介Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后使用命令就可以从 YML 文件配置中创建并启动所有服务。 &#x2F;&#x2F; 暂时用不到","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"服务器","slug":"后端/服务器","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"WebSocket前后端搭建","slug":"WebSocket前后端搭建","date":"2022-12-09T08:09:11.000Z","updated":"2022-12-09T08:13:44.734Z","comments":true,"path":"2022/12/09/WebSocket前后端搭建/","link":"","permalink":"http://example.com/2022/12/09/WebSocket%E5%89%8D%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA/","excerpt":"","text":"简介WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 特点： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 对比传统实现服务器推送技术 ajax轮询 客户端每隔一段时间就发送一次请求，询问服务器是否有新消息 long poll long poll 原理和 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型。当客户端发起请求，服务端收到后如果没有新消息要发送给客户端的话就会等待，一直等待到有新消息再返回，如果时间超时，客户端收到超时的消息后会重新再发送一个请求。 实现流程 搭建后端服务器，初始化项目 创建配置类，注入ServerEndpointExporter对象 1234567@Configurationpublic class webSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 创建WebSocketServer类，编写websocket服务。 12345678910111213141516171819202122232425@ServerEndpoint(&quot;/msgChannel/&#123;id&#125;&quot;)@Componentpublic class WebSocketServer &#123; @OnOpen public void open(@PathParam(&quot;id&quot;)String id, Session session)&#123; System.out.println(&quot;与[&quot;+id+&quot;]建立连接&quot;); &#125; @OnClose public void close() &#123; // 添加关闭会话时的操作 System.out.println(&quot;断开连接&quot;); &#125; @OnError public void error(Throwable t) &#123; // 添加处理错误的操作 t.printStackTrace(); &#125; @OnMessage public void getMessage(String message) &#123; System.out.println(&quot;收到消息:&quot; + message); &#125;&#125; web页面直接创建webSocket对象。 12345678// 创建连接let socket = new WebSocket(&#x27;ws://localhost:9863/msgChannel&#x27;)// 发送消息socket.send(msg)// 监听消息socket.onmessage = (event) =&gt; &#123; console.log(&#x27;Message from server &#x27;, event.data);&#125;; 客户端【Web】1234// 创建连接let socket = new WebSocket(&#x27;ws://localhost:9863/msgChannel&#x27;)// 发送消息socket.send(msg) 重点API构造方法1let aWebSocket = new WebSocket(url [, protocols]); 参数 url 要连接的 URL；这应该是 WebSocket 服务器响应的 URL。 protocols 可选 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个 WebSocket 子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。 实例方法 close()参数 code 可选 一个数字状态码，它解释了连接关闭的原因。如果没有传这个参数，默认使用 1005。CloseEvent的允许的状态码见状态码列表 。 reason 可选 一个人类可读的字符串，它解释了连接关闭的原因。这个 UTF-8 编码的字符串不能超过 123 个字节。 实例方法 send()参数 data 用于传输至服务器的数据。 data必须是以下类型之一： USVString文本字符串【常用】 ArrayBuffer有类型的数组对象 Blob二进制blob数据【常用】 事件 closeWebSocket.onclose 属性返回一个事件监听器，这个事件监听器将在 WebSocket 连接的readyState变为 CLOSED时被调用，它接收一个名字为“close”的 CloseEvent事件。 123WebSocket.onclose = function(event) &#123; console.log(&quot;WebSocket已关闭&quot;);&#125;; 事件 error当websocket的连接由于一些错误事件的发生 (例如无法发送一些数据) 而被关闭时，一个error事件将被触发。 1234const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);socket.addEventListener(&#x27;error&#x27;, function (event) &#123; console.log(&#x27;WebSocket error: &#x27;, event);&#125;); 事件 messagemessage 事件会在 WebSocket 接收到新消息时被触发。 123456// 创建一个 WebSocket 连接const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);// 监听消息socket.onmessage = (event) =&gt; &#123; console.log(&#x27;Message from server &#x27;, event.data);&#125;; 事件 open**WebSocket.onopen**属性定义一个事件处理程序，当WebSocket的连接状态readyState变为1时调用;这意味着当前连接已经准备好发送和接受数据。 12345const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);// 也就是说当服务端也同意建立连接后，该事件就会触发socket.onopen = function(event) &#123; console.log(&quot;WebSocket is open now.&quot;);&#125;; 服务端【java】javax提供了websocket的功能实现。可以直接使用注解的方式进行开发。 重点注解 @OnOpen有连接时的触发函数。 我们可以在用户连接时记录用户的连接带的参数，只需在参数列表中增加参数：@PathParam(“paraName”) String paraName。 @OnMessage收到消息时调用的函数，其中Session是每个websocket特有的数据成员 @OnClose连接关闭时的调用方法。 @OnError发生意外错误时调用的函数。 @ServerEndpoint进行声明接口：@ServerEndpoint(value&#x3D;”&#x2F;websocket&#x2F;{paraName}”) 重点对象和方法Session每个Session代表了两个websocket断点的会话；当websocket握手成功后，websocket就会提供一个打开的Session，可以通过这个Session来对另一个端点发送数据；如果Session关闭后发送数据将会报错。 Session.getBasicRemote().sendText(“message”)向该Session连接的用户发送字符串数据。 Session.getAsyncRemote().sendText(“message”)异步非阻塞向该Session连接的用户发送字符串数据。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.xiaoyi.websocketchat.handler.WebSocketMassageHandler;import com.xiaoyi.websocketchat.handlerMapping.MessageHandlerMapping;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author 小易 * @version 1.0 * @description TODO webSocket服务 * @date 2022/12/9 9:07 */@ServerEndpoint(&quot;/msgChannel/&#123;id&#125;&quot;)@Componentpublic class WebSocketServer &#123; /** 会话集合 */ private static final Map&lt;String, WebSocketServer&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /** 与某个客户端的连接会话，需要通过它来给客户端发送数据 */ private Session session; /** 接收id */ private String id = &quot;&quot;; @OnOpen public void open(@PathParam(&quot;id&quot;)String id, Session session)&#123; this.session = session; this.id = id; sessionMap.put(id, this); System.out.println(&quot;与[&quot;+id+&quot;]建立连接&quot;); &#125; @OnClose public void close() &#123; // 添加关闭会话时的操作 sessionMap.remove(this.id); System.out.println(&quot;与[&quot;+id+&quot;]断开连接&quot;); &#125; @OnError public void error(Throwable t) &#123; // 添加处理错误的操作 System.out.println(&quot;发生错误&quot;); t.printStackTrace(); &#125; @OnMessage public void getMessage(String message) &#123; // 接收到消息后通过处理器适配器获取对应的消息处理器 WebSocketMassageHandler handler = MessageHandlerMapping.getWebSocketMessageHandler(message); // 使用消息处理器处理消息 handler.handler(message, this); &#125; public synchronized void sendMessage(String message) &#123; this.session.getAsyncRemote().sendText(message);//非阻塞式的 &#125;&#125;","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://example.com/categories/WebSocket/"}],"tags":[{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"websocket","slug":"websocket","permalink":"http://example.com/tags/websocket/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Axios跨域","slug":"Axios跨域","date":"2022-11-17T07:35:59.000Z","updated":"2022-11-17T07:37:09.386Z","comments":true,"path":"2022/11/17/Axios跨域/","link":"","permalink":"http://example.com/2022/11/17/Axios%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"1报错信息: Access to XMLHttpRequest at &#x27;http://localhost:8888/cert/certCompany/list2&#x27; from origin &#x27;http://localhost:8889&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. 解决方案 main.js 引入axios 1234//引入axios by zhengkai.blog.csdn.netimport axios from &#x27;axios&#x27;Vue.prototype.$axios = axiosaxios.defaults.baseURL = &#x27;/api&#x27; //自动附加在所有axios请求前面，则可以省略/api，直接写&#x27;/xxxx/xxx&#x27;。否则需要设置&#x27;/api/xxxx/xxx&#x27; config.index.js 改造proxyTable部分，引入虚拟代理 ，请求target这个地址的时候直接写成/api即可。 1234567891011121314151617181920212223dev: &#123; env: require(&#x27;./dev.env&#x27;), port: 8889, autoOpenBrowser: true, assetsSubDirectory: &#x27;static&#x27;, assetsPublicPath: &#x27;/&#x27;, proxyTable: &#123; //axios跨域改造 by zhengkai.blog.csdn.net &#x27;/api&#x27;: &#123; target:&#x27;http://localhost:8888/cert/&#x27;, // 你请求的第三方接口 changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite:&#123; // 路径重写， &#x27;^/api&#x27;: &#x27;&#x27; // 替换target中的请求地址，也就是说/api=/target，请求target这个地址的时候直接写成/api即可。 &#125; &#125; &#125;, // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false &#125; 业务.vue 1234567axios.post(&#x27;/certCompany/list2&#x27;,JSON.stringify(this.searchParam)) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"}]},{"title":"vue中画面样式闪烁","slug":"vue中画面样式闪烁","date":"2022-11-17T07:32:07.000Z","updated":"2022-11-17T07:35:17.745Z","comments":true,"path":"2022/11/17/vue中画面样式闪烁/","link":"","permalink":"http://example.com/2022/11/17/vue%E4%B8%AD%E7%94%BB%E9%9D%A2%E6%A0%B7%E5%BC%8F%E9%97%AA%E7%83%81/","excerpt":"","text":"小型项目中使用 v-cloak 指令是解决屏幕闪动，在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令了。 v-cloak: ​ 可以使用 v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除。 123&lt;div id=&quot;app&quot; v-cloak&gt; &#123;&#123;context&#125;&#125;&lt;/div&gt; 123[v-cloak]&#123; display: none;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"屏幕闪动","slug":"屏幕闪动","permalink":"http://example.com/tags/%E5%B1%8F%E5%B9%95%E9%97%AA%E5%8A%A8/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"服务器","slug":"后端/服务器","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://example.com/categories/WebSocket/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"websocket","slug":"websocket","permalink":"http://example.com/tags/websocket/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"屏幕闪动","slug":"屏幕闪动","permalink":"http://example.com/tags/%E5%B1%8F%E5%B9%95%E9%97%AA%E5%8A%A8/"}]}